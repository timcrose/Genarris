%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Genarris}
\date{Sep 22, 2019}
\release{2.0}
\author{Rithwik Tom, Timothy Rose, Imanuel Bier}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Installation}
\label{\detokenize{index:installation}}
1) Setup MPI and MKL
If already installed and modules exist, load them after unloading all conflicting modules. Note, in this installation tutorial we will use intel including intel's parallel studio package, but other program environments such as gnu will also work.
e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{module} \PYG{n}{unload} \PYG{n}{gnu}
\PYG{n}{module} \PYG{n}{unload} \PYG{n}{openmpi}
\PYG{n}{module} \PYG{n}{load} \PYG{n}{intel}
\PYG{n}{module} \PYG{n}{load} \PYG{n}{impi}
\end{sphinxVerbatim}

If MKL and MPI are already installed but modules do not exist, include the MPI and MKL directories in your environment variables.
e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{}Change to your parallel studio path
export \PYGZdl{}intel=/opt/ohpc/pub/intel/intel18/compilers\PYGZus{}and\PYGZus{}libraries\PYGZus{}2018.3.222/linux
export \PYGZdl{}intel\PYGZus{}parent=/opt/ohpc/pub/intel/intel18

export PATH=\PYGZdq{}\PYGZdl{}intel/mpi/intel64/bin\PYGZus{}ohpc:\PYGZbs{}
\PYGZdl{}intel/mpi/intel64/bin:\PYGZdl{}intel/bin/intel64:\PYGZdl{}PATH\PYGZdq{}

export LD\PYGZus{}LIBRARY\PYGZus{}PATH=\PYGZdq{}\PYGZdl{}intel/mpi/intel64/lib:\PYGZdl{}intel/mpi/mic/lib:\PYGZbs{}
\PYGZdl{}intel/compiler/lib/intel64:\PYGZdl{}intel/compiler/lib/intel64\PYGZus{}lin:\PYGZbs{}
\PYGZdl{}intel/ipp/lib/intel64:\PYGZdl{}intel/mkl/lib/intel64\PYGZus{}lin:\PYGZbs{}
\PYGZdl{}intel/tbb/lib/intel64/gcc4.1:\PYGZbs{}
\PYGZdl{}intel\PYGZus{}parent/debugger\PYGZus{}2018/iga/lib:\PYGZbs{}
\PYGZdl{}intel\PYGZus{}parent/debugger\PYGZus{}2018/libipt/intel64/lib:\PYGZbs{}
\PYGZdl{}intel/daal/lib/intel64\PYGZus{}lin:\PYGZdl{}intel/tbb/lib/intel64\PYGZus{}lin/gcc4.4\PYGZdq{}
\end{sphinxVerbatim}

Also export LD\_PRELOAD to load the parallel studio MKL and Scalapack so importing FHI-aims and numpy does not cause conflict.
e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{export} \PYG{n}{LD\PYGZus{}PRELOAD}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}intel/mkl/lib/intel64\PYGZus{}lin/libmkl\PYGZus{}intel\PYGZus{}lp64.so:}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdl{}intel/mkl/lib/intel64\PYGZus{}lin/libmkl\PYGZus{}sequential.so:}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdl{}intel/mkl/lib/intel64\PYGZus{}lin/libmkl\PYGZus{}core.so:}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdl{}intel/mkl/lib/intel64\PYGZus{}lin/libmkl\PYGZus{}blacs\PYGZus{}intelmpi\PYGZus{}lp64.so:}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdl{}intel/mkl/lib/intel64\PYGZus{}lin/libmkl\PYGZus{}scalapack\PYGZus{}lp64.so:}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdl{}intel/mpi/intel64/lib/libmpi.so.12}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

2) create a python 3.5+ virtual environment
e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{}Change this to your desired anaconda install path
export \PYGZdl{}anaconda=\PYGZdl{}\PYGZob{}HOME\PYGZcb{}/anaconda
mkdir \PYGZdl{}anaconda
cd \PYGZdl{}anaconda
\end{sphinxVerbatim}

download and install anaconda
e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{wget} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{repo}\PYG{o}{.}\PYG{n}{anaconda}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{archive}\PYG{o}{/}\PYG{n}{Anaconda3}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2019.07}\PYG{o}{\PYGZhy{}}\PYG{n}{Linux}\PYG{o}{\PYGZhy{}}\PYG{n}{x86\PYGZus{}64}\PYG{o}{.}\PYG{n}{sh}
\PYG{n}{chmod} \PYG{o}{+}\PYG{n}{x} \PYG{n}{Anaconda3}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2019.07}\PYG{o}{\PYGZhy{}}\PYG{n}{Linux}\PYG{o}{\PYGZhy{}}\PYG{n}{x86\PYGZus{}64}\PYG{o}{.}\PYG{n}{sh}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{Anaconda3}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2019.07}\PYG{o}{\PYGZhy{}}\PYG{n}{Linux}\PYG{o}{\PYGZhy{}}\PYG{n}{x86\PYGZus{}64}\PYG{o}{.}\PYG{n}{sh}
\end{sphinxVerbatim}

Include anaconda's binary in PATH
e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
export PATH=\PYGZdl{}anaconda/anaconda3/bin:\PYGZdl{}PATH
\end{sphinxVerbatim}

Make a python environment called e.g. genarris\_env by installing intelpython3\_core.
e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{conda} \PYG{n}{config} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{add} \PYG{n}{channels} \PYG{n}{intel}
\PYG{n}{conda} \PYG{n}{create} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{n}{genarris\PYGZus{}env} \PYG{n}{intelpython3\PYGZus{}core} \PYG{n}{python}\PYG{o}{=}\PYG{l+m+mi}{3}
\end{sphinxVerbatim}

3) direct your path variables to include the new env
e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{export} \PYG{n}{PYTHONPATH}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}anaconda/anaconda3/envs/genarris\PYGZus{}env/lib/python3.6:}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdl{}anaconda/anaconda3/envs/genarris\PYGZus{}env/lib/python3.6/site\PYGZhy{}packages:}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdl{}PYTHONPATH}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n}{export} \PYG{n}{PATH}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}intel/mpi/intel64/bin\PYGZus{}ohpc:\PYGZdl{}intel/mpi/intel64/bin:}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdl{}intel/bin/intel64:\PYGZdl{}anaconda/anaconda3/envs/intelpython3\PYGZus{}full/bin:}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{\PYGZdl{}anaconda/anaconda3/bin:\PYGZdl{}PATH}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

4) Extract Genarris\_v2.tar.gz into a desired directory and enter it
e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
export \PYGZdl{}genarris=\PYGZdl{}\PYGZob{}HOME\PYGZcb{}/genarris
mkdir \PYGZdl{}genarris
cp Genarris\PYGZus{}v2.tar.gz \PYGZdl{}genarris
cd \PYGZdl{}genarris
tar \PYGZhy{}xzf Genarris\PYGZus{}v2.tar.gz
\end{sphinxVerbatim}

5) Install Genarris. Note, one reason we recommend to create a python virutal env earlier is that running this installation script will remove the ase installation (if any) in the currently active python environment.
e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cd \PYGZdl{}genarris/Genarris
python setup.py install
\end{sphinxVerbatim}

Genarris is now installed. We will first test that Genarris imports and MPI is working correctly with the following test and then the next step will be to compile FHI-aims as a python-importable library if you desire to use FHI-aims.

6) Test that Genarris imports and MPI is working correctly.
Modify the submission script for your backend (here, we used slurm).:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cd \PYGZdl{}genarris/documentation/mpi\PYGZus{}and\PYGZus{}genarris\PYGZus{}test
sbatch mpi\PYGZus{}and\PYGZus{}genarris\PYGZus{}test.sh
\end{sphinxVerbatim}

The desired output is that each rank reports a unique number.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi )}
\makeatletter\def\p@enumii{\p@enumi \theenumi )}\makeatother
\setcounter{enumi}{6}
\item {} 
Compile libaims into a python-importable library

\end{enumerate}

Set ulimit to avoid any possible memory problems:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ulimit} \PYG{o}{\PYGZhy{}}\PYG{n}{s} \PYG{n}{unlimited}
\PYG{n}{ulimit} \PYG{o}{\PYGZhy{}}\PYG{n}{v} \PYG{n}{unlimited}

\PYG{c+c1}{\PYGZsh{} Set OMP\PYGZus{}NUM\PYGZus{}THREADS to 1}
\PYG{n}{export} \PYG{n}{OMP\PYGZus{}NUM\PYGZus{}THREADS}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

Obtain FHI-aims from \sphinxurl{https://aims-git.rz-berlin.mpg.de/aims/FHIaims}
If you don't have permissions, ask Volker Blum at \sphinxhref{mailto:volker.blum@duke.edu}{volker.blum@duke.edu}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
export \PYGZdl{}aims=\PYGZdl{}\PYGZob{}HOME\PYGZcb{}/aims  \PYGZsh{}Change to your desired location for FHI\PYGZhy{}aims
\end{sphinxVerbatim}

In its src directory (\$aims/src), make sure the Makefile has all compilation
flags (user defined settings) commented out.
Copy the make.sys file in the documentation directory of Genarris into
FHI-aims' src directory. The make.sys is pasted here for reference.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cp \PYGZdl{}genarris/documentation/make.sys \PYGZdl{}aims/src
\end{sphinxVerbatim}

Note, this make.sys assumes you are using intel's parallel studio and that your
cluster's backend is intel. If this isn't the case, you'll need to set the
flags accordingly.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{} make.sys
\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
\PYGZsh{} Basic Flags \PYGZsh{}
\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
FC = mpiifort
FFLAGS = \PYGZhy{}O3 \PYGZhy{}ip \PYGZhy{}fp\PYGZhy{}model precise \PYGZhy{}fPIC
F90FLAGS = \PYGZdl{}(FFLAGS)
ARCHITECTURE = Generic
LAPACKBLAS = \PYGZhy{}L\PYGZdl{}\PYGZob{}MKLROOT\PYGZcb{}/lib/intel64 \PYGZbs{}
             \PYGZhy{}lmkl\PYGZus{}intel\PYGZus{}lp64 \PYGZbs{}
             \PYGZhy{}lmkl\PYGZus{}sequential \PYGZbs{}
             \PYGZhy{}lmkl\PYGZus{}core \PYGZbs{}
             \PYGZhy{}lmkl\PYGZus{}blacs\PYGZus{}intelmpi\PYGZus{}lp64 \PYGZbs{}
             \PYGZhy{}lmkl\PYGZus{}scalapack\PYGZus{}lp64
F90MINFLAGS = \PYGZhy{}O0 \PYGZhy{}fp\PYGZhy{}model precise \PYGZhy{}fPIC

\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
\PYGZsh{} Parallelization Flags \PYGZsh{}
\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
USE\PYGZus{}MPI = yes
MPIFC = \PYGZdl{}\PYGZob{}FC\PYGZcb{}
SCALAPACK = \PYGZdl{}\PYGZob{}LAPACKBLAS\PYGZcb{}

\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
\PYGZsh{} C,C++ Flags \PYGZsh{}
\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
CC = icc
CFLAGS = \PYGZhy{}O3 \PYGZhy{}ip \PYGZhy{}fp\PYGZhy{}model precise \PYGZhy{}fPIC
\end{sphinxVerbatim}

Compile FHI-aims as a shared library object:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cd \PYGZdl{}aims/src
make \PYGZhy{}j 20 libaims.scalapack.mpi
\end{sphinxVerbatim}

where the \sphinxcode{\sphinxupquote{20}} is however many cores you'd like to use for compilation.

Make a directory for compiling FHI-aims as a python library
e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mkdir \PYGZdl{}aims/aims\PYGZus{}as\PYGZus{}python\PYGZus{}lib
cd \PYGZdl{}aims/aims\PYGZus{}as\PYGZus{}python\PYGZus{}lib
\end{sphinxVerbatim}

\# Copy the Makefile and aims\_w.f90 in the Genarris documentation directory to this directory. A copy of it has been pasted here for reference. Note that you will need to change the libaims version (currently shown as 190522). Again, you'll need to change the f90exec and/or fcompiler flags if your backend is not intel. aims\_w.f90 is a wrapper script to interface with FHI-aims.
e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cp \PYGZdl{}genarris/Genarris/documentation/Makefile \PYGZdl{}aims/aims\PYGZus{}as\PYGZus{}python\PYGZus{}lib
cp \PYGZdl{}genarris/Genarris/documentation/aims\PYGZus{}w.f90 \PYGZdl{}aims/aims\PYGZus{}as\PYGZus{}python\PYGZus{}lib
\end{sphinxVerbatim}

Create the Makefile with the following contents:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
LIBAIMS=\PYGZdl{}\PYGZob{}aims\PYGZcb{}/lib/libaims.190522.scalapack.mpi.so
include\PYGZus{}dir=\PYGZdl{}\PYGZob{}anaconda\PYGZcb{}/anaconda3/envs/genarris\PYGZus{}env/include

aims\PYGZus{}w.so: aims\PYGZus{}w.f90
    f2py \PYGZhy{}\PYGZhy{}f90exec=mpiifort \PYGZhy{}\PYGZhy{}fcompiler=intelem \PYGZhy{}m aims\PYGZus{}w \PYGZbs{}
         \PYGZhy{}c aims\PYGZus{}w.f90 \PYGZdl{}\PYGZob{}LIBAIMS\PYGZcb{} \PYGZhy{}I\PYGZdl{}\PYGZob{}include\PYGZus{}dir\PYGZcb{}

clean:
    rm aims\PYGZus{}w.*.so
\end{sphinxVerbatim}

Compile FHI-aims as an importable python library!:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{make}
\end{sphinxVerbatim}

8) Test that FHI-aims can run a job
Modify the submission script in the \sphinxcode{\sphinxupquote{\$genarris/documentation/aims\_test}}
directory to run on your backend (here we used slurm).:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
export PYTHONPATH=\PYGZdl{}PYTHONPATH:\PYGZdl{}aims/aims\PYGZus{}as\PYGZus{}python\PYGZus{}lib
cd \PYGZdl{}genarris/documentation/aims\PYGZus{}test
sbatch aims\PYGZus{}test.sh
\end{sphinxVerbatim}


\chapter{Introduction to Running Genarris}
\label{\detokenize{index:introduction-to-running-genarris}}

\section{Configuration File}
\label{\detokenize{index:configuration-file}}
Genarris is a random crystal structure generation code that can be adapted to
perform \sphinxstyleemphasis{ab initio} crystal structure prediction. The modularity of Genarris
is achieved through the sequential execution of procedures. The execution of
Genarris is controlled by a \sphinxhref{https://docs.python.org/3.4/library/configparser.html}{configuration} file. Below is a small example
of a configuration file for Genarris.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{Genarris\PYGZus{}master}\PYG{p}{]}
\PYG{n}{procedures} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Pygenarris\PYGZus{}Structure\PYGZus{}Generation}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}

\PYG{p}{[}\PYG{n}{pygenarris\PYGZus{}structure\PYGZus{}generation}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} Path to the single molecule file to used for crystal structure generation}
\PYG{n}{molecule\PYGZus{}path} \PYG{o}{=} \PYG{n}{relaxed\PYGZus{}molecule}\PYG{o}{.}\PYG{o+ow}{in}
\PYG{c+c1}{\PYGZsh{} Number of cores (MPI ranks) to run this section with}
\PYG{n}{num\PYGZus{}cores} \PYG{o}{=} \PYG{l+m+mi}{56}
\PYG{c+c1}{\PYGZsh{} Number of OpenMP Threads}
\PYG{n}{omp\PYGZus{}num\PYGZus{}threads} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{num\PYGZus{}structures} \PYG{o}{=} \PYG{l+m+mi}{5000}
\PYG{n}{Z} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{sr} \PYG{o}{=} \PYG{l+m+mf}{0.85}
\PYG{n}{tol} \PYG{o}{=} \PYG{l+m+mf}{0.00001}
\PYG{n}{max\PYGZus{}attempts\PYGZus{}per\PYGZus{}spg\PYGZus{}per\PYGZus{}rank} \PYG{o}{=} \PYG{l+m+mi}{1000000000}
\PYG{n}{geometry\PYGZus{}out\PYGZus{}filename} \PYG{o}{=} \PYG{n}{glycine\PYGZus{}4mpc}\PYG{o}{.}\PYG{n}{out}
\PYG{n}{output\PYGZus{}format} \PYG{o}{=} \PYG{n}{json}
\PYG{n}{output\PYGZus{}dir} \PYG{o}{=} \PYG{n}{glycine\PYGZus{}4mpc\PYGZus{}raw\PYGZus{}jsons}
\end{sphinxVerbatim}

\sphinxstylestrong{Sections} of the configuration file are denoted by square brakets, \sphinxcode{\sphinxupquote{{[}...{]}}}.
All parameters that are specified below a section are called \sphinxstylestrong{options}. The
workflow of Genarris can be precisely controlled by the user by specifying the
order of the desired procedures in \sphinxcode{\sphinxupquote{{[}Genarris\_master{]}}}. The user must also
include the corresponding section for each procedure listed in
\sphinxcode{\sphinxupquote{{[}Genarris\_master{]}}}. Each section may have many options which are required,
optional, or inferred.

This document details the options for procedures that are executed in the Genarris 2.0
\sphinxstyleemphasis{Robust} workflow. In order these are:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Relax\PYGZus{}Single\PYGZus{}Molecule}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Estimate\PYGZus{}Unit\PYGZus{}Cell\PYGZus{}Volume}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Pygenarris\PYGZus{}Structure\PYGZus{}Generation}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Run\PYGZus{}Rdf\PYGZus{}Calc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Affinity\PYGZus{}Propagation\PYGZus{}Fixed\PYGZus{}Clusters}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FHI\PYGZus{}Aims\PYGZus{}Energy\PYGZus{}Evaluation}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Affinity\PYGZus{}Propagation\PYGZus{}Fixed\PYGZus{}Clusters}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Run\PYGZus{}FHI\PYGZus{}Aims\PYGZus{}Batch}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\end{sphinxVerbatim}

There are many options that can be specified and modified for each section.
All of these options are specified in this document under the
\sphinxstylestrong{Configuration File Options} section of each procedure. For a detailed
description of the workflow, see the {\hyperref[\detokenize{index:detailed-instructions}]{\sphinxcrossref{detailed instructions}}} section.


\section{Option Category}
\label{\detokenize{index:option-category}}\label{\detokenize{index:category}}
There are three \sphinxstyleemphasis{categories} of \sphinxstylestrong{Configuration File Options}. These are \sphinxstyleemphasis{required},
\sphinxstyleemphasis{optional}, and \sphinxstyleemphasis{inferred}. In the \sphinxstylestrong{Configuration File Options}, these categories
are specified after the \sphinxstyleemphasis{type} of the option, such as \sphinxstyleemphasis{int}, \sphinxstyleemphasis{float}, or \sphinxstyleemphasis{bool}.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstyleemphasis{Required} options have no category placed after the type in the
documentation. These options are required to be in the configuration
file for execution of Genarris.

\item {} 
\sphinxstyleemphasis{Optional} arguments are specified after the option \sphinxstyleemphasis{type}.
These areguments have default settings built into the code perform
well in general. The user may specify these \sphinxstyleemphasis{optional} arguments
in the configuration file to have more control over the program
executing.

\item {} 
\sphinxstyleemphasis{Inferred} options are specified after the option \sphinxstyleemphasis{type}. These options
may be present in multiple different procedures. For example, the option
\sphinxcode{\sphinxupquote{aims\_lib\_dir}} is needed in the \sphinxcode{\sphinxupquote{Relax\_Single\_Molecule}},
\sphinxcode{\sphinxupquote{FHI\_Aims\_Energy\_Evaluation}}, and \sphinxcode{\sphinxupquote{Run\_FHI\_Aims\_Batch}}.
But, because it is an inferred parameter, it only needs to be specified
once in the earliest procedure in which occurs and then it will be
inferred by all further procedures. Options which are inferred are thus
optional in all proceeding sections.

\end{enumerate}


\section{Output Formats}
\label{\detokenize{index:output-formats}}
There are three output formats supported within the Genarris source code. These
are \sphinxstyleemphasis{json}, \sphinxstyleemphasis{geo}, or \sphinxstyleemphasis{both}.
\begin{itemize}
\item {} 
The \sphinxstyleemphasis{json} file format is the native structure file format for Genarris.
This file format supports storing the structure ID, the geometry, and
property information.

\item {} 
The \sphinxstyleemphasis{geo} file format is the file format support by FHI-aims. Additionally,
this file format is support by \sphinxhref{http://jmol.sourceforge.net}{Jmol} , a 3D chemical structure visualizer,
and by \sphinxhref{https://wiki.fysik.dtu.dk/ase/}{ASE}, the atomic simulation environment tools written for Python.

\item {} 
The user may also specify \sphinxstyleemphasis{both}, in which case both the \sphinxstyleemphasis{json} file
and \sphinxstyleemphasis{geo} file for every structure will be produced.

\end{itemize}


\chapter{Running Genarris Tutorial}
\label{\detokenize{index:running-genarris-tutorial}}

\section{Quick start}
\label{\detokenize{index:quick-start}}
\sphinxcode{\sphinxupquote{cd}} to the tutorial/RDF directory and modify \sphinxcode{\sphinxupquote{aims\_lib\_dir}} in \sphinxcode{\sphinxupquote{ui.conf}}
to point to the directory containing your aims library wrapper file (the one compiled
with f2py). Adapt \sphinxcode{\sphinxupquote{sub\_genarris.sh}} to your cluster schdueling submission script
type (the example is slurm) and options (slurm options, mpi executable, number
of cores etc.). Then submit e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sbatch} \PYG{n}{sub\PYGZus{}genarris}\PYG{o}{.}\PYG{n}{sh}
\end{sphinxVerbatim}


\section{Input options in ui.conf}
\label{\detokenize{index:input-options-in-ui-conf}}
See {\hyperref[\detokenize{index:documentation}]{\sphinxcrossref{documentation}}}.


\section{Description of Log Files}
\label{\detokenize{index:description-of-log-files}}
There are multiple log files created when running Genarris. The files are
separated by the contents they contain. This makes debugging easier, for example,
because all error information is saved in a single location.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Genarris.log}}: \leavevmode A log of what is currently being run and other info is printed here. 
The amount of info can be made less verbose by commenting out the verbose
option in the ui.conf for the various procedures.

\item {} 
\sphinxcode{\sphinxupquote{Genarris.err}}: Error messages may appear here.

\item {} 
\sphinxcode{\sphinxupquote{stdout}}: Named something different depending on your submission script,
this is the standard output which may contain environment info,
cgenarris output log info, and sometimes error messages.

\end{itemize}


\section{Detailed Instructions}
\label{\detokenize{index:detailed-instructions}}\label{\detokenize{index:id1}}
Genarris will run the procedures specified by the procedures option in the
\sphinxcode{\sphinxupquote{Genarris\_master}} section in the order they appear in the list.
It begins with the \sphinxcode{\sphinxupquote{Relax\_Single\_Molecule}} procedure which creates a folder
called \sphinxcode{\sphinxupquote{structure\_dir\_for\_relaxing\_single\_molecule}} to store the
molecule geometry file. Calls to FHI-aims create a folder structure starting
with the folder name inputted with the \sphinxcode{\sphinxupquote{aims\_output\_dir}} option.
That folder contains a folder for every structure in the inputted structure
directory (in this case, there is just one structure). The
inputted control file is copied to each of those subfolders. A copy of the
geometry file in FHI-aims and json format is also copied to the
corresponding subdirectory. Genarris replicas move from folder to folder,
performing an FHI-aims calculation in each one. This creates
the aims output file \sphinxcode{\sphinxupquote{aims.out}} and possibly a relaxed geometry file
\sphinxcode{\sphinxupquote{geometry.in.next\_step}}. Genarris will look to see if the single molecule
was relaxed and if so, use that geometry in subsequent procedures.

When pygenarris is run, each core will output structures to its own
\sphinxcode{\sphinxupquote{geometry.out}} file. Each of these are \sphinxcode{\sphinxupquote{geometry.in}} format concatenated.
When pygenarris completes, these individual files will be appended to a
single \sphinxcode{\sphinxupquote{geometry.out}} file if desired and each structure will be
output to the \sphinxcode{\sphinxupquote{output\_dir}} specified as a json file. A json file is like a
python dictionary which contains key, value pairs for metadata
about the structure and is required for subsequent steps. pygenarris may also
output the \sphinxcode{\sphinxupquote{cutoff\_matrix}} which contains distance cutoff
values between atoms i and j which are derived from the sr inputted
(see the paper for more details). Because the number of structures generated
currently must be a multiple of the number of allowed space groups for the
given molecule and Z, we have:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{num\PYGZus{}structures\PYGZus{}per\PYGZus{}allowed\PYGZus{}SG\PYGZus{}per\PYGZus{}rank} \PYG{o}{=}
                \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ceil}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{num\PYGZus{}structures}\PYG{p}{)} \PYG{o}{/}
                \PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{comm}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)} \PYG{o}{*} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{num\PYGZus{}compatible\PYGZus{}spgs}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

and so the total number of structures generated could
be more than the number specified in \sphinxcode{\sphinxupquote{ui.conf}}. See the documentation, but
there is an option for choosing to keep them all or only select
the \sphinxcode{\sphinxupquote{num\_structures}} structures desired. Structures are niggli reduced
before being output to jsons.

Then the \sphinxcode{\sphinxupquote{Run\_Rdf\_Calc}} procedure is run. It yields a directory of jsons
specified by its \sphinxcode{\sphinxupquote{output\_dir}} option. These jsons are the same as the
ones output by Pygenarris except now they have the RDF vector as a recorded
piece of metadata. A distance matrix is also output in the form
of a memory map which drastically saves on memory usage.

Alternatively, the RCD procedures may be run. \sphinxcode{\sphinxupquote{RCD\_Calculation}} creates an
\sphinxcode{\sphinxupquote{output\_dir}} with the jsons including their RCD vectors. It also
outputs some other log files: \sphinxcode{\sphinxupquote{RCD\_report.out}} and \sphinxcode{\sphinxupquote{rcd\_vectors.info}}.
\sphinxcode{\sphinxupquote{RCD\_Difference\_Folder\_Inner}} will compute the pairwise distances between all
structures and output a distance matrix in the form of a memory map.

Next, Affinity Propagation begins by printing the affinity matrix that
corresponds to the distance matrix outputted in the previous step.
It then outputs a directory with all structures in the raw pool, but now they
include more metadata such as the cluster id that AP assigned
it to as well as the exemplar of its cluster. AP also outputs a directory of
the exemplars, and the distance matrix of those exemplars which has
the same name as the first distance matrix file name but with a 1 appended
to the name.

The next call to FHI-aims computes the energies of the exemplars outputted in
the previous step. It creates an \sphinxcode{\sphinxupquote{aims\_output\_dir}} with name specified in
the \sphinxcode{\sphinxupquote{ui.conf}}. The resultant jsons are then dumped to the corresponding
\sphinxcode{\sphinxupquote{output\_dir}} which are the same as the exemplars but now have the energy
property included.

Then, AP creates the affintity matrix corresponding to the second distance
matrix and clusters the structures with energies and outputs a directory
for all those structures but now they contain the cluster assigned by this AP.
The tutorial asks the second round of clustering to output the
structure with the minimum energy from each cluster. These are the structures
output to \sphinxcode{\sphinxupquote{sample\_structures\_exemplars\_2}}.

These structures are relaxed in the subdirectories of \sphinxcode{\sphinxupquote{aims\_output\_dir}} for
\sphinxcode{\sphinxupquote{Run\_FHI\_Aims\_Batch}}. The relaxed structures are then niggli reduced and are
output to this section's \sphinxcode{\sphinxupquote{output\_dir}}. The structures output to \sphinxcode{\sphinxupquote{output\_dir}}
also contain other metadata such as spglib's new determination of the space
group.


\chapter{Genarris 2.0 Procedures for Robust Workflow}
\label{\detokenize{index:genarris-2-0-procedures-for-robust-workflow}}\label{\detokenize{index:documentation}}

\section{Description}
\label{\detokenize{index:description}}
This section details all arguments and configuration file
options for the procedures executed by the Robust Genarris 2.0 workflow. Each
procedure is a class function of the of the \sphinxcode{\sphinxupquote{Genarris}} master class.
The documentation follows a standard format for each procedure. The name
of the procedure is given first followed by a short description of the function
the function it performs. Below the description is the the configuration file
options subsection. This section gives the name, the data type,
the {\hyperref[\detokenize{index:category}]{\sphinxcrossref{\DUrole{std,std-ref}{Option Category}}}}, and a description of each option which is accepted by the
procedure. By referencing this documentation, the user can obtain precise
control over the execution of Genarris procedures.


\section{Genarris Procedures}
\label{\detokenize{index:genarris-procedures}}\index{Genarris (class in Genarris.genarris\_master)@\spxentry{Genarris}\spxextra{class in Genarris.genarris\_master}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Genarris.genarris_master.Genarris}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Genarris.genarris\_master.}}\sphinxbfcode{\sphinxupquote{Genarris}}}{\emph{inst\_path}}{}
Master class of Genarris. It controls all aspects of the
Genarris workflow which can be executed individually or sequantially.
Begins by reading and intepreting the configuration file.
Calls the defined procedures with the options specified in the
configuration file. Some options may be inferred from previous sections
if they are not present in every section.
\index{Affinity\_Propagation\_Fixed\_Clusters() (Genarris.genarris\_master.Genarris method)@\spxentry{Affinity\_Propagation\_Fixed\_Clusters()}\spxextra{Genarris.genarris\_master.Genarris method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Genarris.genarris_master.Genarris.Affinity_Propagation_Fixed_Clusters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Affinity\_Propagation\_Fixed\_Clusters}}}{\emph{comm}}{}
AP that explores the setting of preference in order to generate
desired number of clusters.
\subsubsection*{Configuration File Options}
\begin{description}
\item[{output\_dir}] \leavevmode{[}str{]}
Path to the directory where the chosen structures will be stored.

\item[{preference\_range}] \leavevmode{[}list{]}
List of two values as the {[}min, max{]} of the range of allowable
preference values.

\item[{structure\_dir}] \leavevmode{[}str, inferred{]}
Path to the directory of files to be used for the calculation.
Default is to infer this value from the previous section.

\item[{dist\_mat\_input\_file}] \leavevmode{[}str, inferred{]}
Path to the distance matrix output from the descriptor calculation.
Default is to infer this value from the previous sections.

\item[{output\_format}] \leavevmode{[}str, optional{]}
Format the structure files should be saved as. Default is both.

\item[{cluster\_on\_energy}] \leavevmode{[}bool, optional{]}
Uses energy values to determine examplars. Structures with the
lowest energy values from each cluster are selected.
Default is False.

\item[{plot\_histograms}] \leavevmode{[}bool, optional{]}
If histogram plots should be created of the volume and space
groups. Default is False.

\item[{num\_of\_clusters}] \leavevmode{[}int or float, optional{]}
Float, must be less than 0. Selects a fraction of the structures.
Int, selects specific number of structures equal to int.
Default is 0.1.

\item[{num\_of\_clusters\_tolerance}] \leavevmode{[}int, optional{]}
Algorithm will stop if it has generated the number of clusters
within the number of desired clusters and this tolerance.
Default is 0.

\item[{max\_sampled\_preferences}] \leavevmode{[}int, optional{]}
Maximum number of preference values to try.

\item[{output\_without\_success}] \leavevmode{[}bool, optional{]}
Whether to perform output procedures if the algorithm has reached
the maximum number of sampled preferences without finding the
correct number of clusters. Default is False.

\item[{affinity\_type}] \leavevmode{[}list, optional{]}
List of {[}type of afinity, value{]} argument Scikit-Learn AP alogrithm.

\item[{affinity\_matrix\_path}] \leavevmode{[}str, optional{]}
Path to the affinity matrix to use for the AP algorithm.
Default is \sphinxcode{\sphinxupquote{affinity\_matrix.dat}}.

\item[{damping}] \leavevmode{[}float, optional{]}
damping argument for Scikit-Learn AP algorithm. Default is 0.5.

\item[{convergence\_iter}] \leavevmode{[}int, optional{]}
convergence\_iter argument for Scikit-Learn AP algorithm.
Default is 15.

\item[{max\_iter}] \leavevmode{[}int, optional{]}
max\_iter argument for Scikit-Learn AP algorithm. Default is 1000.

\item[{preference}] \leavevmode{[}int, optional{]}
preference argument for Scikit-Learn AP algorithm. Default is None.

\item[{verbose\_output}] \leavevmode{[}bool, optional{]}
verbose argument for Scikit-Learn AP algorithm. Default is False.

\item[{property\_key}] \leavevmode{[}str, optional{]}
Key which the AP cluster will be stored in the properties of
each structure object. Default is \sphinxcode{\sphinxupquote{AP\_cluster}}.

\item[{output\_file}] \leavevmode{[}str, optional{]}
Path where info about the AP alogrithm execution will be stored.
Default is \sphinxcode{\sphinxupquote{./AP\_cluster.info}}.

\item[{exemplars\_output\_dir}] \leavevmode{[}str, optional{]}
If provided, will output the examplars of each cluster to this
folder. Default is None.

\item[{exemplars\_output\_format}] \leavevmode{[}str, optional{]}
File format of structures to be output. Default is both.

\item[{structure\_suffix}] \leavevmode{[}str, optional{]}
Suffix to apply to structure files which are written.
Default is \sphinxcode{\sphinxupquote{.json}}.

\item[{output\_dir\_2: str, inferred}] \leavevmode
Code automatically looks for the option output\_dir\_2 if the
output directory already exists. This is how the code currently
identifies that AP is running for a second time. Default behavior
is to not use this option if output\_dir does not already exist.

\item[{num\_of\_clusters\_2: int or float, optional}] \leavevmode
num\_of\_clusters for second clustering step. Default value is 0.1.

\item[{output\_file\_2}] \leavevmode{[}str, inferred{]}
Use if running AP algorithm twice, such as in the Robust workflow.
Default is to use output\_file.

\item[{exemplars\_output\_dir\_2}] \leavevmode{[}str, inferred{]}
Exemplars output directory if second clustering step is used.
Default is to use exemplars\_output\_dir.

\item[{cluster\_on\_energy\_2}] \leavevmode{[}str, inferred{]}
How to choose examplars for the second clustering step. Default
is to use cluster\_on\_energy value.

\item[{energy\_name\_2}] \leavevmode{[}str, inferred{]}
Energy name to use for second clustering step. Default is to use
energy\_name.

\end{description}

\end{fulllineitems}

\index{Estimate\_Unit\_Cell\_Volume() (Genarris.genarris\_master.Genarris method)@\spxentry{Estimate\_Unit\_Cell\_Volume()}\spxextra{Genarris.genarris\_master.Genarris method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Genarris.genarris_master.Genarris.Estimate_Unit_Cell_Volume}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Estimate\_Unit\_Cell\_Volume}}}{\emph{comm}}{}
Performs volume estimation using a machine learned model train on the
CSD and based on Monte Carlo volume integration and topological
molecular fragments. See Genarris 2.0 paper for full description.
\subsubsection*{Configuration File Options}
\begin{description}
\item[{volume\_mean}] \leavevmode{[}float, optional{]}
If provided, uses this value as the volume generation mean without
using the ML model to etimate the volume.

\item[{volume\_std}] \leavevmode{[}float, optional{]}
If provided, uses this value for structure generation, otherwise
a default value of 0.075 multiplied by the prediction volume per
unit cell is provided.

\end{description}

\end{fulllineitems}

\index{FHI\_Aims\_Energy\_Evaluation() (Genarris.genarris\_master.Genarris method)@\spxentry{FHI\_Aims\_Energy\_Evaluation()}\spxextra{Genarris.genarris\_master.Genarris method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Genarris.genarris_master.Genarris.FHI_Aims_Energy_Evaluation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{FHI\_Aims\_Energy\_Evaluation}}}{\emph{comm}, \emph{world\_comm}, \emph{MPI\_ANY\_SOURCE}, \emph{num\_replicas}}{}
Runs Self-Consistent Field calculation on a pool of structures.
\subsubsection*{Configuration File Options}

See {\hyperref[\detokenize{index:Genarris.genarris_master.Genarris.Run_FHI_Aims_Batch}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Run\_FHI\_Aims\_Batch()}}}}}

\end{fulllineitems}

\index{Pygenarris\_Structure\_Generation() (Genarris.genarris\_master.Genarris method)@\spxentry{Pygenarris\_Structure\_Generation()}\spxextra{Genarris.genarris\_master.Genarris method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Genarris.genarris_master.Genarris.Pygenarris_Structure_Generation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Pygenarris\_Structure\_Generation}}}{\emph{comm}}{}
Uses the Genarris module written in C to perform structure generation.
This module enables generation on special positions.
\subsubsection*{Configuration File Options}
\begin{description}
\item[{molecule\_path}] \leavevmode{[}str{]}
Path to the relaxed molecule geometry.

\item[{output\_format}] \leavevmode{[}str, optional, default="json"{]}
Determines the type of file which will be output for each
structure. Can be one of: json, geo, both.

\item[{output\_dir}] \leavevmode{[}str{]}
Path to the directory which will contain all generated structures
which pass the intermolecular distance checks.

\item[{num\_structures}] \leavevmode{[}int{]}
Target number of structures to generate.

\item[{Z}] \leavevmode{[}int{]}
Number of molecules per cell to generate.

\item[{volume\_mean}] \leavevmode{[}float, optional{]}
See {\hyperref[\detokenize{index:Genarris.genarris_master.Genarris.Estimate_Unit_Cell_Volume}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Estimate\_Unit\_Cell\_Volume()}}}}}

\item[{volume\_std}] \leavevmode{[}float, optional{]}
See {\hyperref[\detokenize{index:Genarris.genarris_master.Genarris.Estimate_Unit_Cell_Volume}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Estimate\_Unit\_Cell\_Volume()}}}}}

\item[{sr}] \leavevmode{[}float, optional{]}
Defines the minimum intermolecular distance that is considered
physical by multiplying the sum of the van der Waals radii of the
interacting atoms by sr. Default value is 0.85.

\item[{tol}] \leavevmode{[}float, optional{]}
Tolerance to be used to identify space groups compatible with the
input molecule.

\item[{max\_attempts\_per\_spg\_per\_rank}] \leavevmode{[}int{]}
Defines the maximum number of attempts the structure generator
makes before moving on to the next space group.

\item[{num\_structures\_per\_allowed\_SG\_per\_rank}] \leavevmode{[}int{]}
Number of structures per space group per rank which will be
generated by Pygenarris.

\item[{geometry\_out\_filename}] \leavevmode{[}str{]}
Filename where all structures generated by Pygenarris will be found.

\item[{omp\_num\_threads}] \leavevmode{[}int{]}
Number of OpenMP threads to pass into Pygenarris

\item[{truncate\_to\_num\_structures}] \leavevmode{[}bool{]}
If true, will reduce pool to exactly the number defined by
num\_structures.

\end{description}

\end{fulllineitems}

\index{Run\_Rdf\_Calc() (Genarris.genarris\_master.Genarris method)@\spxentry{Run\_Rdf\_Calc()}\spxextra{Genarris.genarris\_master.Genarris method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Genarris.genarris_master.Genarris.Run_Rdf_Calc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Run\_Rdf\_Calc}}}{\emph{comm}}{}
Runs RDF calculation for the pool of generated structures. RDF
descriptor is similar to that described in Behler and Parrinello 2007.
Then calculates the structure difference matrix.
\subsubsection*{Configuration File Options}
\begin{description}
\item[{structure\_dir}] \leavevmode{[}str, inferred{]}
Path to the directory of structures to evaluate.

\item[{dist\_mat\_fpath}] \leavevmode{[}str{]}
Path to file to write distance matrix to.

\item[{output\_dir}] \leavevmode{[}str{]}
Path of directory to write structures to (will create if it DNE).
If 'no\_new\_output\_dir' then input structures will be overwritten.

\item[{normalize\_rdf\_vectors: bool,optional}] \leavevmode
Whether to normalize the rdf vectors over the columns of the
feature matrix before using them to compute the distance matrix.
Default is Falase.

\item[{standardize\_distance\_matrix: bool}] \leavevmode
If True, standardizes the distance matrix. The method is to divide
all elements by the max value in the distance matrix.
Because it is a distance matrix and thus all elements are positive,
the standardized elements will be in the range {[}0, 1{]}.
Default is False.

\item[{save\_envs: bool, optional}] \leavevmode
Whether to save the environment vectors calculated by the RDF
method in the output structure files. Default is False.

\item[{cutoff}] \leavevmode{[}float, optional{]}
Cutoff radius to apply to the atom centered symmetry function.
Default is 12.

\item[{n\_D\_inter}] \leavevmode{[}int, optional{]}
Number of dimensions to use for each type of pair-wise
interatomic interaction found in the structure. Default is 12.

\item[{init\_scheme}] \leavevmode{[}str, optional{]}
Can be centered or shifted, as described in Gastegger et al. 2018.
Default is shifted.

\item[{eta\_range}] \leavevmode{[}list, optional{]}
List of two floats which define the range for eta parameter in
Gastegger et al. 2018. Default is {[}0.05,0.5{]}.

\item[{Rs\_range}] \leavevmode{[}list, optional{]}
List of two floats which define the range for Rs parameter in
Gastegger et al. 2018. Default is {[}{[}0.1,12{]}.

\item[{pdist\_distance\_type}] \leavevmode{[}str,optional{]}
Input parameter for the pdist function. Default is Euclidean.

\end{description}

\end{fulllineitems}

\index{Relax\_Single\_Molecule() (Genarris.genarris\_master.Genarris method)@\spxentry{Relax\_Single\_Molecule()}\spxextra{Genarris.genarris\_master.Genarris method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Genarris.genarris_master.Genarris.Relax_Single_Molecule}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Relax\_Single\_Molecule}}}{\emph{comm}, \emph{world\_comm}, \emph{MPI\_ANY\_SOURCE}, \emph{num\_replicas}}{}
Calls run\_fhi\_aims\_batch using the provided single molecule path.
\subsubsection*{Configuration File Options}

See {\hyperref[\detokenize{index:Genarris.genarris_master.Genarris.Run_FHI_Aims_Batch}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Run\_FHI\_Aims\_Batch()}}}}}

\end{fulllineitems}

\index{Run\_FHI\_Aims\_Batch() (Genarris.genarris\_master.Genarris method)@\spxentry{Run\_FHI\_Aims\_Batch()}\spxextra{Genarris.genarris\_master.Genarris method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Genarris.genarris_master.Genarris.Run_FHI_Aims_Batch}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Run\_FHI\_Aims\_Batch}}}{\emph{comm}, \emph{world\_comm}, \emph{MPI\_ANY\_SOURCE}, \emph{num\_replicas}}{}
Runs FHI-aims calculations on a pool of structures using num\_replicas.
\subsubsection*{Configuration File Options}
\begin{description}
\item[{verbose}] \leavevmode{[}bool{]}
Controls verbosity of output.

\item[{energy\_name}] \leavevmode{[}str{]}
Property name which the calculated energy will be stored with in the
Structure file.

\item[{output\_dir}] \leavevmode{[}str{]}
Path to the directory where the output structure file will be saved.

\item[{aims\_output\_dir}] \leavevmode{[}str{]}
Path where the aims calculation will take place.

\item[{aims\_lib\_dir}] \leavevmode{[}str, inferred{]}
Path to the location of the directory containing the FHI-aims library
file.

\item[{molecule\_path}] \leavevmode{[}str{]}
Path to the geometry.in file of the molecule to be calculated if
called using harris\_single\_molecule\_prep or relax\_single\_molecule.

\item[{structure\_dir}] \leavevmode{[}str, inferred{]}
Path to the directory of structures to be calculated if calculation
was called not using harris\_single\_molecule\_prep or
relax\_single\_molecule.

\item[{Z}] \leavevmode{[}int, inferred{]}
Number of molecules per cell.

\end{description}

\end{fulllineitems}


\end{fulllineitems}




\renewcommand{\indexname}{Index}
\printindex
\end{document}